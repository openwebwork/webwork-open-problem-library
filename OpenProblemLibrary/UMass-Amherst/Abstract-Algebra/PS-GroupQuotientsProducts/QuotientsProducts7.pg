## DBsubject('Abstract Algebra')
## DBchapter('Groups')
## DBsection('Product of groups')
## KEYWORDS('products of groups, generators')
## Level(4)
## TitleText1('')
## EditionText1('')
## AuthorText1('')
## Section1('')
## Problem1('')
## Author('Siman Wong')
## Institution('University of Massachusetts Amherst')



DOCUMENT();        

loadMacros(
"PG.pl",
"PGstandard.pl",
"MathObjects.pl",
"PGbasicmacros.pl",
"PGchoicemacros.pl",
"PGanswermacros.pl",
"PGauxiliaryFunctions.pl",
"algebraMacros.pl"
);

TEXT(beginproblem());
$showPartialCorrectAnswers = 0;


#
#  In this problem we ask students to find a pair of elements that
#  generate U(n1 n2) where n1, n2 are distinct primes  (or 4 or 9)
#


  # pick two coprime elements from the list with product > 20 and < 100
  #
@set  = ( 3, 4, 5, 7, 9, 11, 13, 17, 19, 23);

  # a list smallest primitive root of the respective modulus
  #
@prim = ( 2, 3, 2, 3, 2,  2,  2,  3,  2,  5);

$r1 = random(0, @set-1, 1);
$n1 = $set[$r1];
$r2 = random(0, @set-1, 1);
$n2 = $set[$r2];
$m  = $n1 * $n2;
while( gcd($n1, $n2) >1 || $m<21 || $m>100 )
{
  $r1 = random(0, @set-1, 1);
  $n1 = $set[$r1];
  $r2 = random(0, @set-1, 1);
  $n2 = $set[$r2];
  $m  = $n1 * $n2;
}

$ma = max($n1, $n2);

  # primitive roots of the respective modulus
  #
$pm1 = @prim[$r1];
$pm2 = @prim[$r2];



  # use brute force search to chinese-life pm1 and pm2, i.e. to solve
  #  u1 = pm1 (mod n1)      u2 = 1   (mod n1)
  #     = 1   (mod n2)         = pm2 (mod n2)
  #
for($i=2; $i<$m; $i++) {
  if ( ($i % $n1 == $pm1)  &  ($i % $n2)==1 ) {
    $u1 = $i;
  }
}
for($i=2; $i<$m; $i++) {
  if ( ($i % $n1 == 1)  &  ($i % $n2)==$pm2 ) {
    $u2 = $i;
  }
}



BEGIN_TEXT

Find a pair of elements \(A, B\) in 
\( 
   U( $m ) 
\)
such that
\( 
   U( $m ) 
\)
is isomorphic to 
\(
  \langle A \rangle  \times  \langle B \rangle
\).
Be sure to enter your answer as a comma-separated list of two POSITIVE integers \( < $m \). $BR $BR

\(A, B=\) \{ ans_rule(20) \} $BR



END_TEXT

#
# Input:  modulus m
#         student's input sx
#         student's input sy
#
# Ouput:  Determine if 
#           (order of sx in Z_m) x (order of sx in Z_m) = m
#

ANS( List( $u1, $u2 )->cmp(
     list_checker => sub {
       my( $correct, $student, $anshash, $value ) = @_;  
       my( $sx, $sy ) = @$student;

       # make sure the student entered exactly two numbers, that they are real, that they are integers, and that they are both 0 < A,B < m.
       #
       # NOTE:  Since each element be in the range [1, m-1], both elements
       #        are not trivial
       #

	   if( @$student != 2 || !Value::isReal( $sx ) || !Value::isReal( $sy ) || int( $sx ) != $sx || int( $sy ) != $sy || gcd($sx,$m) >1 || gcd($sy,$m) >1 )
	   {
		  return( 0, "Enter exactly two integers A,B coprime to $m." );
	   }
       
       # find smallest positive integer power of sx and sy that is = 1 (mod m)
       # to avoid integer overflow we check (mod n1) and (mod n2)
	   my $i = $j = 1;
	   $i++ while ( (($sx**$i)% $n1 >1) || (($sx**$i)% $n2 >1) );
	   $j++ while ( (($sy**$j)% $n1 >1) || (($sy**$j)% $n2 >1) );

       # create a list of elements of U(m)
       #   -- the k-th entry is 1 if it is in U(m), and 0 if not

	   my @used = ();
	   @used[0] = 0;
	   for($k=1; $k<$m; $k++) {
	     if ( gcd($k, $m)>1 ) {
	       @used[$k] = 0;
	     }
	     else {
	       @used[$k] = 1;
	     }
           }

        # run through all elements in the subgroup genereted by 
	# the students' input, and for each one put "1" in the list

  	  $tx = 1;
	  for($ci=0; $ci<$i; $ci++ ) {
	    $tx = ($tx * $sx) % $m;
  	    $ty = 1;
	    for($cj=0; $cj<$j; $cj++) {
	      $ty = ($ty * $sy) % $m;
	      $w  = ($tx * $ty) % $m;
	      @used[ $w ] = 0;
            }
          }

       # check to see if every element of U(m) has been used
       #
	  $missed = 0;
	  for($k = 1; $k<$m; $k++) {
	    if ( @used[$k]>0 ) {
	      $missed = 1;
            }
	  }

       return ( $missed == 0 ) ? 2 : 0;      
     }
   )
);



SOLUTION(EV3(<<'END_SOLUTION'));
$PAR SOLUTION $PAR

By the Chinese remainder theorem,
\(
  U($m) \simeq U($n1)\times U($n2).
\)
We readily check that
\(
  $pm1  \pmod{$n1}
\)
is a generator of 
\(
  U($n1)
\)
and
\(
  $pm2  \pmod{$n2}
\)
is a generator of 
\(
  U($n2),
\)
so
\(
  \alpha :=  ($pm1  \pmod{$n1},  $1 \pmod{$n2})
\)
and
\(
  \beta := ($1  \pmod{$n1},  $pm2 \pmod{$n2})
\)
together generate 
\(
  U($n1)\times U($n2).
\)
But we are looking for generators of \( U($m) \), so we need to lift 
\(
  \alpha, \beta
\)
back to \(U($m)\).  For that we use the Chinese remainder theorem again,
and we get that

$BR
\(     $u1       \equiv $pm1 \pmod{$n1}   \)  $BR
\( \phantom{$u1} \equiv 1    \pmod{$n2},  \)  $BR


\(     $u2       \equiv 1    \pmod{$n1}   \)  $BR
\( \phantom{$u2} \equiv $pm2 \pmod{$n2},  \)  $BR

so \( $u1, $u2 \) together generate \( U($m) \).

$BR$BR

Comments: (i) If we use  a different generator for \( U( $ma ) \) 
we will 
end up with a different pair of generators for \( U($m) \).  In particular,
this problem has more than one possible solution.

$BR

(ii) Note that \( \alpha, \beta \) generate
\(
  U($n1)\times U($n2)
\)
but we need to lift these back to \( U($m) \). This is a common mistake.

END_SOLUTION


COMMENT("Complete solution included.");








ENDDOCUMENT();       