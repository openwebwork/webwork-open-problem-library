## DBsubject('Number theory')
## DBchapter('Congruences')
## DBsection('Fast powering')
## KEYWORDS('fast powering')
## Level(2)
## TitleText1('')
## EditionText1('')
## AuthorText1('')
## Section1('')
## Problem1('')
## Author('Siman Wong and Patrick O'Brien')
## Institution('University of Massachusetts Amherst')

DOCUMENT();       

loadMacros(
"PG.pl",
"MathObjects.pl",
"PGbasicmacros.pl",
"PGchoicemacros.pl",
"PGanswermacros.pl",
"PGauxiliaryFunctions.pl"
);

TEXT(beginproblem());
$showPartialCorrectAnswers = 0;

Context()->strings->add(Y=>{});
Context()->strings->add(N=>{});


#
# Basic fast exponentiation problem
# Warning/Note:
#   If you simply compute  (a**b) % c  you will get the wrong answer
#   most likely because the numbers are too big.  Since the (random)
#   modulus in this problem is always prime, we can apply Fermat's
#   little theorem and first reduce the exponent modulo c-1 and that
#   takes care of this issue.
#

%set1 = ( '0' => 3,
          '1' => 4,
          '2' => 5,);

%set2 = ( '0' => 19,
          '1' => 23,
          '2' => 29,
          '3' => 31,
          '4' => 37,
          '5' => 41,);

# base of exponentiation
#
$aa = random(0,2,1);
$a = $set1{$aa};


# modulus
#
$cc = random(0,5,1);
$c = $set2{$cc};
$d = $c - 1;


# randomize the exponent
#
$i1 = random(3,7,1);
$i2 = random(2,6,1);
$i3 = random(1,4,1);
$i4 = random(0,3,1);
while ($i1==$i2 || $i1==$i3 || $i1==$i4 || $i2==$i3 || $i2==$i4 || $i3==$i4) {
  $i1 = random(3,7,1);
  $i2 = random(2,6,1);
  $i3 = random(1,4,1);
  $i4 = random(0,3,1);
}

$r = random(3, 4, 1);
if ($r==3) {
  $b = 2**$i1 + 2**$i2 + 2**$i3;
}
else {
  $b = 2**$i1 + 2**$i2 + 2**$i3 + 2**$i4;
}


$pow = ($a**($b % $d)) % $c;


@answer = ();
if ($r==3) {
  for($k=0; $k<8; $k++) {
    if ($i1==$k || $i2==$k || $i3==$k) {
      @answer[$k] = "Y";
    }
    else {
      @answer[$k] = "N";
    }
  }
}
else {
  for($k=0; $k<8; $k++) {
    if ($i1==$k || $i2==$k || $i3==$k || $i4==$k) {
      @answer[$k] = "Y";
    }
    else {
      @answer[$k] = "N";
    }
  }
}








TEXT(EV3(<<'EOT'));

Which of the following values are needed to compute \($a^{$b} \pmod {$c}\) using fast exponentiation? Mark Y/N accordingly: $BR $BR


\{ begintable(3) \}
\{ row( "\(i \)", "\($a^{2^{i}} \pmod{$c}\)", "\(Y/N\)") \}
\{ row( "0", ($a**(2**0)     ) % $c, ans_rule(10)) \}
\{ row( "1", ($a**(2**1)     ) % $c, ans_rule(10)) \}
\{ row( "2", ($a**(2**2)     ) % $c, ans_rule(10)) \}
\{ row( "3", ($a**(2**3)     ) % $c, ans_rule(10)) \}
\{ row( "4", ($a**(2**4)     ) % $c, ans_rule(10)) \}
\{ row( "5", ($a**(2**5 % $d)) % $c, ans_rule(10)) \}
\{ row( "6", ($a**(2**6 % $d)) % $c, ans_rule(10)) \}
\{ row( "7", ($a**(2**7 % $d)) % $c, ans_rule(10)) \}

\{ endtable() \} $BR

Use these values to compute \($a^{$b} \pmod {$c}\) $BR $BR

\($a^{$b} \pmod {$c} =\) \{ ans_rule(10) \}


EOT



ANS( Compute( $answer[0] )->cmp() );
ANS( Compute( $answer[1] )->cmp() );
ANS( Compute( $answer[2] )->cmp() );
ANS( Compute( $answer[3] )->cmp() );
ANS( Compute( $answer[4] )->cmp() );
ANS( Compute( $answer[5] )->cmp() );
ANS( Compute( $answer[6] )->cmp() );
ANS( Compute( $answer[7] )->cmp() );

ANS(str_cmp($pow) );





ENDDOCUMENT();       