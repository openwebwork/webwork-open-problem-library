## DBsubject(Abstract algebra)
## DBchapter(Rings)
## DBsection(Ideals and homomorphisms)
## Institution(University of Massachusetts Amherst)
## Author(Daniel Nichols and Siman Wong)
## Level(3)
## MO(1)
## KEYWORDS('ideals, generators')


DOCUMENT();        # This should be the first executable line in the problem.

loadMacros(
  "PGstandard.pl",
  "MathObjects.pl",
  "algebraMacros.pl",
  "PGcourse.pl"
);


TEXT(beginproblem());
$showPartialCorrectAnswers = 0;

Context("Numeric");

# create g = gcd( modulus, c )

@chooseG = ( 8, 10, 12, 15, 16, 18, 20 );
$i = random(0, scalar(@chooseG)-1, 1);
$g = $chooseG[$i];

@chooseNumbers = ( 4, 5, 7, 9 );
fyshuffle( ~~@chooseNumbers );

# two coprime numbers chosen at random from @chooseNumbers;
($a,$b) = @chooseNumbers;

$modulus = $a*$g;

$c = $b*$g;

# so $g = gcd($c, $modulus)

# uniq eliminates duplicates 
# https://stackoverflow.com/questions/7651/how-do-i-remove-duplicate-items-from-an-array-in-perl

sub uniq {
    my %seen;
    grep !$seen{$_}++, @_;
}

# ideals contained in (g) are generated by multiples of g

@subideal_gens = map { gcd( $_ * $g, $modulus ) % $modulus } (0..$a-1) ;

$ans0 = List( uniq( @subideal_gens ) );

# ideals containing (g) are generated by factors of g
# these are all divisors of $modulus so they generate distinct ideals

$ans1 = List( grep { $g % $_ == 0 } ( 1 .. $g ) );
	
$customGrader = sub {
  my($correct,$student,$ansHash,$value)=@_;
  my $studN = scalar(@$student);
  my $corrN = scalar(@$correct);
  my $score = 0; 
  my @errors = ();
  my $i,$j;
  # check that student's answers are integers and they 
  # match distinct correct answers
  my $matched;
  for ($i=0; $i<$studN; $i++){
    my $ith = Value::List->NameForNumber($i+1);
    if ( $student->[$i]->type ne "Number" or 
         ($student->[$i]) !=  floor($student->[$i]) 
    ){
      push(@errors, "Your $ith entry is not an integer");
      return (0,@errors);
    }
    if ($student->[$i] < 0 or $student->[$i] > $modulus -1){
       push(@errors,"Represent elements \(b\in \mathbb{Z}_{$modulus}\) by integers \(0\leq b < $modulus\)");
       return (0,@errors);
    }
    for ($j=0; $j<$i; $j++){
      if ( (($student->[$i])-($student->[$j])) % $modulus == 0 ){
        my $jth = Value::List->NameForNumber($j+1);
        push(@errors, "Your $jth and $ith answers are equivalent mod $modulus") unless $ansHash->{isPreview};
        return (0,@errors);
      }
    }
    for ($j=0; $j<$i; $j++){
      if ( gcd( $student->[$i], $modulus ) == gcd( $student->[$j], $modulus ) ){
        my $jth = Value::List->NameForNumber($j+1);
        push(@errors, "Your $jth and $ith answers generate the same ideal in \(\displaystyle \mathbb{Z}_{$modulus}\)") unless $ansHash->{isPreview};
        return (0,@errors);
      }
    }
    $matched = 0;
    for ($j=0; $j<$corrN; $j++){
      if ( ( gcd($student->[$i], $modulus) - ($correct->[$j]) ) % $modulus == 0 ){
        $matched = 1;
        $score++;
        last;
      }
    }
    if ( ! $matched ){
      push(@errors, "Your $ith answer is wrong") unless $ansHash->{isPreview};
    }
  }
  if ( $studN < $corrN ){ push(@errors, "Your list of answers should be longer") unless $ansHash->{isPreview}; }
  if ( $studN > $corrN ){ push(@errors, "Your list of answers is too long") unless $ansHash->{isPreview}; }
  return ($score, @errors);
};

Context()->texStrings;
BEGIN_TEXT
It is a fact that every ideal of \( \{ cyclic( $modulus ) \} \) is of the form \( ( b ) \) for some element \( b \) of \( \{ cyclic( $modulus ) \} \). $PAR

(a) Find all the ideals \(I\) of \(\{ cyclic( $modulus ) \} \) that are contained in the ideal \( ( $c ) \): 
\[ I \subseteq ($c) \subseteq \{cyclic( $modulus)\}.\] 
In the answer blank below list one generator for each ideal.  Separate the generators by commas.$BR
\{ ans_rule( 20 ) \} $PAR

(b) Find all the ideals \(J\) of \( \{ cyclic( $modulus ) \} \) that contain the ideal \( ( $c ) \): 
\[ ($c) \subseteq J \subseteq \{ cyclic( $modulus )\}.\] 
As in part (a), list one generator for each ideal, separated by commas. $BR
\{ ans_rule( 20 ) \} $PAR

Remember that an ideal contains, and is contained in, itself!
END_TEXT
Context()->normalStrings;

# special answer checker -- accept any generator g for a given ideal
# if  gcd( g, $modulus) = correct generator 

# need special answer checkers: (c) contains (x) in Z_m if and only
## if gcd(c,m) | gcd(x,m).

ANS($ans0->cmp( list_checker => $customGrader ));
ANS($ans1->cmp( list_checker => $customGrader ));

COMMENT( "" );


ENDDOCUMENT(); 
