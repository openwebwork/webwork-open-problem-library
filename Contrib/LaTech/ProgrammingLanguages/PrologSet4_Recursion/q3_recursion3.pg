## DESCRIPTION
## Generates two mutually recursive Prolog predicates and asks for
## unification results when used.
## ENDDESCRIPTION

## DBsubject(Programming Languages)
## DBchapter(Prolog)
## DBsection(Recursion)
## Date(01/01/2026)
## Institution(Louisiana Tech)
## Author(Jason Terry)
## Level(2)
## KEYWORDS('programming languages','prolog','unification','recursion','mutual')


DOCUMENT();

## Load libraries
loadMacros(
"PGstandard.pl",
"PGcourse.pl",
"contextArbitraryString.pl",
"PGML.pl"
);

## Change context to strings answers
Context("ArbitraryString");

## Create function to normalize strings into specific format
sub normalize {
    my ($s) = @_;               # get input string
    $s =~ tr/ //ds;             # strip all whitespace
    $s =~ tr/.//ds;             # strip all periods
    @arr = split(/,/,$s);       # split string on commas
    @sorted = lex_sort(@arr);   # sort strings
    $new = join(',',@sorted);   # recombine into one string
    return($new);               # return recombined string
}

## Create custom answer checker for prolog input
$prologChecker = sub {
        my ($correct,$student,$ansHash) = @_;  # get correct and student MathObjects
        $correct = $correct->string;
        $student = $student->string;
        return (normalize($correct) eq normalize($student));  # return 1 if correct, 0 otherwise
};

## Create first recursive function
sub f {
    my $n = $_[0];
    if ($n == 0) {
        return($r1);
    } else {
        return( $n + g($n-1) );
    }
}

## Create second recursive function
sub g {
    my $n = $_[0];
    if ($n == 0) {
        return($r2);
    } else {
        return( $n + f($n-1) );
    }
}

## Create random parameters
$r1 = random(1,3,1);
$r2 = random(4,6,1);

## Create random inputs
$n1 = random(5,7,1);

## Create answers to problems
$a1 = f(1);
$a2 = g(1);
$a3 = f(3);
$a4 = f($n1);
$a5 = g($n1);

## Create answers to questions
$ans1 = String("R=$a1")->cmp(
    checker => $prologChecker
);

$ans2 = String("R=$a2")->cmp(
    checker => $prologChecker
);

$ans3 = String("R=$a3")->cmp(
    checker => $prologChecker
);
    
$ans4 = String("R=$a4")->cmp(
    checker => $prologChecker
);

$ans5 = String("R=$a5")->cmp(
    checker => $prologChecker
);

## Display question
TEXT(beginproblem());

BEGIN_PGML
Suppose Prolog has read the following database.

    *f(N,R) :- integer(N), N>0, N1 is N-1, g(N1,X), R is N+X.*

    *f(0,[$r1]).*

    *g(N,R) :- integer(N), N>0, N1 is N-1, f(N1,X), R is N+X.*

    *g(0,[$r2]).*

Determine whether the following Prolog statements would succeed or fail, and then which variables, if any, would be instantiated to which values. Write your answer on the blank line provided *IN THE CORRECT FORMAT AS FOLLOWS*.

If the statement fails, your response should be:

    *false*

If the statement succeeds and there are no variable instantiations, your response should be:

    *true*

If the statement succeeds and there are variable instantiations, your response should be:

    *<Variable1> = <value1>, <Variable2> = <value2>, <etc.>*

===

    *f(1,R).*

    [________________________________________]{$ans1}

===

    *g(1,R).*

    [________________________________________]{$ans2}

===

    *f(3,R).*

    [________________________________________]{$ans3}

===

    *f([$n1],R).*

    [________________________________________]{$ans4}

===

    *g([$n1],R).*

    [________________________________________]{$ans5}

===

END_PGML

BEGIN_PGML_SOLUTION
Solution:

===

    *f(1,R).*

    R = [$a1]

===

    *g(1,R).*

    R = [$a2]

===

    *f(3,R).*

    R = [$a3]

===

    *f([$n1],R).*

    R = [$a4]

===

    *g([$n1],R).*

    R = [$a5]

===

END_PGML_SOLUTION

ENDDOCUMENT();
